{
  "version": 3,
  "sources": ["../../src/HashRouter.js", "../../src/utils/RouterUtils.js", "../../src/utils/Route.js"],
  "sourcesContent": ["import {Stringer} from '@techexp/jshelper'\nimport {cleanPath, getHashPath} from './utils/RouterUtils'\nimport {Route} from './utils/Route'\n\nexport function createRouter() {\n  return new HashRouter()\n}\n\nclass HashRouter {\n  constructor() {\n    this.routes = []\n\n    const hashHandler = ev => hashChangeHandler(ev, this.routes)\n    const loadHandler = ev => hashChangeHandler(ev, this.routes, true)\n\n    window.addEventListener('hashchange', hashHandler, false)\n    window.addEventListener('load', loadHandler, false)\n  }\n\n  add(path, handler) {\n    this.routes.push({route: new Route(path), handler})\n  }\n\n  go(hashPath) {\n    hashPath = '#' + cleanPath(hashPath)\n    const base = Stringer.substringBefore(window.location.href, '#')\n    const href = base + hashPath\n    window.history.pushState(null, null, hashPath)\n    window.location.href = href\n  }\n}\n\n\nfunction hashChangeHandler(ev, routes, isLoad = false) {\n  const newPath = getNewPath(ev, isLoad)\n  if (newPath === undefined) return\n\n  const params = {}\n  const handler = findHandler(routes, newPath, params)\n  if (handler) {\n    handler(newPath, params)\n  }\n}\n\nfunction getNewPath(ev, isLoad) {\n  if (isLoad) {\n    return getHashPath(ev.target.location.href)\n  }\n  const oldPath = getHashPath(ev.oldURL)\n  const newPath = getHashPath(ev.newURL)\n\n  return oldPath === newPath ? undefined : newPath\n}\n\nfunction findHandler(routes, path, params) {\n  const found = routes.find(r => r.route.isMatch(path, params))\n  return found ? found.handler : false\n}\n", "import {Stringer} from '@techexp/jshelper'\n\nexport function getHashPath(href) {\n  href = Stringer.substringAfter(href, '#')\n  return cleanPath(href)\n}\n\nexport function cleanPath(path) {\n  return Stringer.strip(path, ' /#')\n}", "import {cleanPath} from './RouterUtils'\n\nexport class Route {\n  constructor(path) {\n    this.parts = parsePath(path)\n  }\n\n  /**\n   * Check if given path matches this route\n   * @param {String} path\n   * @param {Object, optional} params An object to populate with path parameters and values\n   */\n  isMatch(path, params = {}) {\n    const pathItems = tokenizePath(path)\n    if (this.parts.length !== pathItems.length) return false\n\n    for (let i = 0; i < pathItems.length; i++) {\n      const part = this.parts[i]\n      const item = pathItems[i]\n      if (! isPartMatch(part, item)) return false\n\n      if (part.type === 'param') {\n        params[part.value] = item\n      }\n    }\n    return true\n  }\n}\n\n/** Return an array of objects {type: 'param|regex|string', value: 'Value of part'} */\nfunction parsePath(path) {\n  return tokenizePath(path).map(p => parsePart(p))\n}\n\nfunction tokenizePath(path) {\n  return cleanPath(path).split('/').map(p => p.trim()).filter(p => p.length > 0)\n}\n\nfunction parsePart(part) {\n  if (part.startsWith(':')) {\n    return {type: 'param', value: part.substring(1)}\n  }\n\n  if (part.startsWith('[') && part.endsWith(']')) {\n    const value = part.substring(1, part.length - 1)\n    return {type: 'regex', value: new RegExp(value)}\n  }\n  return {type: 'string', value: part}\n}\n\nfunction isPartMatch(part, s) {\n  if (part.type === 'param') return true\n  if (part.type === 'string') return s === part.value\n  if (part.type === 'regex') return part.value.test(s)\n  return false\n}\n"],
  "mappings": "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",
  "names": ["Stringer", "Stringer"]
}
