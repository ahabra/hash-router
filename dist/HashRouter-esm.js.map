{
  "version": 3,
  "sources": ["../../src/HashRouter.js", "../../src/utils/RouterUtils.js", "../../src/utils/Route.js"],
  "sourcesContent": ["import {Stringer} from '@techexp/jshelper'\nimport {cleanPath, getHashPath} from './utils/RouterUtils'\nimport {Route} from './utils/Route'\n\nexport function createRouter() {\n  return new HashRouter()\n}\n\nclass HashRouter {\n  constructor() {\n    this.routes = []\n\n    const hashHandler = ev => hashChangeHandler(ev, this.routes)\n    const loadHandler = ev => hashChangeHandler(ev, this.routes, true)\n\n    window.addEventListener('hashchange', hashHandler, false)\n    window.addEventListener('load', loadHandler, false)\n  }\n\n  add(path, handler) {\n    this.routes.push({route: new Route(path), handler})\n  }\n\n  go(hashPath) {\n    hashPath = '#' + cleanPath(hashPath)\n    const base = Stringer.substringBefore(window.location.href, '#')\n    const href = base + hashPath\n    window.history.pushState(null, null, hashPath)\n    window.location.href = href\n  }\n}\n\n\nfunction hashChangeHandler(ev, routes, isLoad = false) {\n  const newPath = getNewPath(ev, isLoad)\n  if (newPath === undefined) return\n\n  const params = {}\n  const handler = findHandler(routes, newPath, params)\n  if (handler) {\n    handler(newPath, params)\n  }\n}\n\nfunction getNewPath(ev, isLoad) {\n  if (isLoad) {\n    return getHashPath(ev.target.location.href)\n  }\n  const oldPath = getHashPath(ev.oldURL)\n  const newPath = getHashPath(ev.newURL)\n\n  return oldPath === newPath ? undefined : newPath\n}\n\nfunction findHandler(routes, path, params) {\n  const found = routes.find(r => r.route.isMatch(path, params))\n  return found ? found.handler : false\n}\n", "import {Stringer} from '@techexp/jshelper'\n\nexport function getHashPath(href) {\n  href = Stringer.substringAfter(href, '#')\n  return cleanPath(href)\n}\n\nexport function cleanPath(path) {\n  return Stringer.strip(path, ' /#')\n}", "import {cleanPath} from './RouterUtils'\n\nexport class Route {\n  constructor(path) {\n    this.parts = parsePath(path)\n  }\n\n  /**\n   * Check if given path matches this route\n   * @param {String} path\n   * @param {Object, optional} params An object to populate with path parameters and values\n   */\n  isMatch(path, params = {}) {\n    const pathItems = tokenizePath(path)\n    if (this.parts.length !== pathItems.length) return false\n\n    for (let i = 0; i < pathItems.length; i++) {\n      const part = this.parts[i]\n      const item = pathItems[i]\n      if (! isPartMatch(part, item)) return false\n\n      if (part.type === 'param') {\n        params[part.value] = item\n      }\n    }\n    return true\n  }\n}\n\n/** Return an array of objects {type: 'param|regex|string', value: 'Value of part'} */\nfunction parsePath(path) {\n  return tokenizePath(path).map(p => parsePart(p))\n}\n\nfunction tokenizePath(path) {\n  return cleanPath(path).split('/').map(p => p.trim()).filter(p => p.length > 0)\n}\n\nfunction parsePart(part) {\n  if (part.startsWith(':')) {\n    return {type: 'param', value: part.substring(1)}\n  }\n\n  if (part.startsWith('[') && part.endsWith(']')) {\n    const value = part.substring(1, part.length - 1)\n    return {type: 'regex', value: new RegExp(value)}\n  }\n  return {type: 'string', value: part}\n}\n\nfunction isPartMatch(part, s) {\n  if (part.type === 'param') return true\n  if (part.type === 'string') return s === part.value\n  if (part.type === 'regex') return part.value.test(s)\n  return false\n}\n"],
  "mappings": ";;;;;;;AAAA;;;ACAA;AAEO,qBAAqB,MAAM;AAChC,SAAO,SAAS,eAAe,MAAM;AACrC,SAAO,UAAU;AAAA;AAGZ,mBAAmB,MAAM;AAC9B,SAAO,SAAS,MAAM,MAAM;AAAA;;;ACNvB,kBAAY;AAAA,EACjB,YAAY,MAAM;AAChB,SAAK,QAAQ,UAAU;AAAA;AAAA,EAQzB,QAAQ,MAAM,SAAS,IAAI;AACzB,UAAM,YAAY,aAAa;AAC/B,QAAI,KAAK,MAAM,WAAW,UAAU;AAAQ,aAAO;AAEnD,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,OAAO,KAAK,MAAM;AACxB,YAAM,OAAO,UAAU;AACvB,UAAI,CAAE,YAAY,MAAM;AAAO,eAAO;AAEtC,UAAI,KAAK,SAAS,SAAS;AACzB,eAAO,KAAK,SAAS;AAAA;AAAA;AAGzB,WAAO;AAAA;AAAA;AAKX,mBAAmB,MAAM;AACvB,SAAO,aAAa,MAAM,IAAI,OAAK,UAAU;AAAA;AAG/C,sBAAsB,MAAM;AAC1B,SAAO,UAAU,MAAM,MAAM,KAAK,IAAI,OAAK,EAAE,QAAQ,OAAO,OAAK,EAAE,SAAS;AAAA;AAG9E,mBAAmB,MAAM;AACvB,MAAI,KAAK,WAAW,MAAM;AACxB,WAAO,CAAC,MAAM,SAAS,OAAO,KAAK,UAAU;AAAA;AAG/C,MAAI,KAAK,WAAW,QAAQ,KAAK,SAAS,MAAM;AAC9C,UAAM,QAAQ,KAAK,UAAU,GAAG,KAAK,SAAS;AAC9C,WAAO,CAAC,MAAM,SAAS,OAAO,IAAI,OAAO;AAAA;AAE3C,SAAO,CAAC,MAAM,UAAU,OAAO;AAAA;AAGjC,qBAAqB,MAAM,GAAG;AAC5B,MAAI,KAAK,SAAS;AAAS,WAAO;AAClC,MAAI,KAAK,SAAS;AAAU,WAAO,MAAM,KAAK;AAC9C,MAAI,KAAK,SAAS;AAAS,WAAO,KAAK,MAAM,KAAK;AAClD,SAAO;AAAA;;;AFlDF,wBAAwB;AAC7B,SAAO,IAAI;AAAA;AAGb,uBAAiB;AAAA,EACf,cAAc;AACZ,SAAK,SAAS;AAEd,UAAM,cAAc,QAAM,kBAAkB,IAAI,KAAK;AACrD,UAAM,cAAc,QAAM,kBAAkB,IAAI,KAAK,QAAQ;AAE7D,WAAO,iBAAiB,cAAc,aAAa;AACnD,WAAO,iBAAiB,QAAQ,aAAa;AAAA;AAAA,EAG/C,IAAI,MAAM,SAAS;AACjB,SAAK,OAAO,KAAK,CAAC,OAAO,IAAI,MAAM,OAAO;AAAA;AAAA,EAG5C,GAAG,UAAU;AACX,eAAW,MAAM,UAAU;AAC3B,UAAM,OAAO,UAAS,gBAAgB,OAAO,SAAS,MAAM;AAC5D,UAAM,OAAO,OAAO;AACpB,WAAO,QAAQ,UAAU,MAAM,MAAM;AACrC,WAAO,SAAS,OAAO;AAAA;AAAA;AAK3B,2BAA2B,IAAI,QAAQ,SAAS,OAAO;AACrD,QAAM,UAAU,WAAW,IAAI;AAC/B,MAAI,YAAY;AAAW;AAE3B,QAAM,SAAS;AACf,QAAM,UAAU,YAAY,QAAQ,SAAS;AAC7C,MAAI,SAAS;AACX,YAAQ,SAAS;AAAA;AAAA;AAIrB,oBAAoB,IAAI,QAAQ;AAC9B,MAAI,QAAQ;AACV,WAAO,YAAY,GAAG,OAAO,SAAS;AAAA;AAExC,QAAM,UAAU,YAAY,GAAG;AAC/B,QAAM,UAAU,YAAY,GAAG;AAE/B,SAAO,YAAY,UAAU,SAAY;AAAA;AAG3C,qBAAqB,QAAQ,MAAM,QAAQ;AACzC,QAAM,QAAQ,OAAO,KAAK,OAAK,EAAE,MAAM,QAAQ,MAAM;AACrD,SAAO,QAAQ,MAAM,UAAU;AAAA;",
  "names": []
}
